---
name: Publish Python 🐍 distributions 📦 to PyPI
on:
  push:
    tags:
      - "v*"
jobs:
  check-status:
    runs-on: ubuntu-latest
    if: github.repository_owner == 'gepa-ai'
    outputs:
      status_checks_passed: ${{ steps.check_status.outputs.passed }}
    steps:
      - uses: actions/checkout@v4
      - name: Check if all status checks are passing
        id: check_status
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Get the latest commit SHA on main branch
          git fetch origin main
          LATEST_COMMIT=$(git rev-parse origin/main)
          
          echo "Checking status checks for commit: $LATEST_COMMIT"
          
          # Wait for status checks to complete (with timeout)
          echo "Waiting for status checks to complete..."
          for i in {1..30}; do
            # Check if all required status checks are passing, excluding this workflow
            # Get all status checks and filter out the current workflow
            echo "Fetching status checks for commit: $LATEST_COMMIT"
            
                      # Get all status checks first
          ALL_STATUSES=$(gh api repos/${{ github.repository }}/commits/$LATEST_COMMIT/statuses 2>/dev/null || echo "")
          if [ -z "$ALL_STATUSES" ]; then
            echo "Failed to fetch status checks from main branch, trying tag commit..."
            # Try to get status checks from the tag commit itself
            TAG_COMMIT=$(git rev-parse $GITHUB_REF)
            ALL_STATUSES=$(gh api repos/${{ github.repository }}/commits/$TAG_COMMIT/statuses 2>/dev/null || echo "")
            if [ -z "$ALL_STATUSES" ]; then
              echo "Failed to fetch status checks from GitHub API"
              echo "This might be a new repository or the API call failed"
              echo "Assuming all checks passed for new repository"
              echo "passed=true" >> "$GITHUB_OUTPUT"
              break
            fi
          fi
            echo "Raw status response: $ALL_STATUSES"
            
            # Filter out the current workflow and extract states
            ALL_CHECKS=$(echo "$ALL_STATUSES" | jq -r '.statuses[] | select(.context != "Publish Python 🐍 distributions 📦 to PyPI") | .state' 2>/dev/null || echo "")
            
            # If jq fails or returns empty, try alternative approach
            if [ -z "$ALL_CHECKS" ]; then
              echo "jq filtering failed, trying alternative approach..."
              # Use grep to filter out the current workflow context and extract states
              ALL_CHECKS=$(echo "$ALL_STATUSES" | grep -o '"state":"[^"]*"' | sed 's/"state":"//g' | sed 's/"//g' | grep -v "Publish Python 🐍 distributions 📦 to PyPI" || echo "")
            fi
            
            # If still empty, check if there are any status checks at all
            if [ -z "$ALL_CHECKS" ]; then
              echo "No status checks found, checking if this is a new repository..."
              # Check if there are any status checks at all
              TOTAL_STATUSES=$(echo "$ALL_STATUSES" | jq -r '.statuses | length' 2>/dev/null || echo "0")
              echo "Total status checks found: $TOTAL_STATUSES"
              
              # If no status checks, consider it as passed (new repository or no other workflows)
              if [ "$TOTAL_STATUSES" -eq 0 ]; then
                echo "No status checks found, assuming all checks passed"
                echo "passed=true" >> "$GITHUB_OUTPUT"
                break
              fi
            fi
            
            echo "Filtered status checks: $ALL_CHECKS"
            
            # Debug: Show all status contexts to understand what's being filtered
            echo "All status contexts:"
            echo "$ALL_STATUSES" | jq -r '.statuses[] | .context + ": " + .state' 2>/dev/null || echo "Failed to extract contexts"
            
            # Check if any non-current workflow checks are still pending
            PENDING_COUNT=$(echo "$ALL_CHECKS" | grep -c "pending" || echo "0")
            FAILED_COUNT=$(echo "$ALL_CHECKS" | grep -c "failure\|error" || echo "0")
            SUCCESS_COUNT=$(echo "$ALL_CHECKS" | grep -c "success" || echo "0")
            
            echo "Status check summary: $SUCCESS_COUNT success, $PENDING_COUNT pending, $FAILED_COUNT failed"
            
            if [ "$FAILED_COUNT" -gt 0 ]; then
              echo "Some status checks failed"
              echo "passed=false" >> "$GITHUB_OUTPUT"
              exit 1
            elif [ "$PENDING_COUNT" -eq 0 ] && [ "$SUCCESS_COUNT" -gt 0 ]; then
              echo "All required status checks are passing"
              echo "passed=true" >> "$GITHUB_OUTPUT"
              break
            else
              echo "Some status checks still pending... (attempt $i/30)"
              sleep 10
            fi
          done
          
          # If we reach here without setting passed=true, status checks didn't complete in time
          if [ "$(echo ${{ steps.check_status.outputs.passed }})" != "true" ]; then
            echo "Status checks did not complete within timeout"
            echo "passed=false" >> "$GITHUB_OUTPUT"
            exit 1
          fi

  extract-tag:
    runs-on: ubuntu-latest
    needs: check-status
    if: github.repository_owner == 'gepa-ai' && needs.check-status.outputs.status_checks_passed == 'true'
    outputs:
      version: ${{ steps.extract_tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
      - id: extract_tag
        name: Extract tag name
        run: |
          # Extract tag and remove 'v' prefix to get semver
          TAG=$(echo $GITHUB_REF | cut -d / -f 3)
          VERSION=${TAG#v}
          echo "tag=$VERSION" >> "$GITHUB_OUTPUT"

  build-and-publish-test-pypi:
    needs: [check-status, extract-tag]
    if: github.repository_owner == 'gepa-ai' && needs.check-status.outputs.status_checks_passed == 'true'
    runs-on: ubuntu-latest
    environment:
      name: pypi
    permissions:
      id-token: write # IMPORTANT: mandatory for trusted publishing
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Set up latest uv
        uses: astral-sh/setup-uv@v6
        with:
          version: latest
      - name: Install build dependencies
        run: uv pip install ".[build]"
      - name: Get correct version for TestPyPI release
        id: check_version
        run: |
          VERSION=${{ needs.extract-tag.outputs.version }}  
          PACKAGE_NAME="gepa"
          echo "Checking if $VERSION for $PACKAGE_NAME exists on TestPyPI"  
          NEW_VERSION=$(python3 .github/workflows/build_utils/test_version.py $PACKAGE_NAME $VERSION)  
          echo "Version to be used for TestPyPI release: $NEW_VERSION"  
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
      - name: Update version in pyproject.toml
        run: sed -i '/#replace_package_version_marker/{n;s/version="[^"]*"/version="${{ needs.extract-tag.outputs.version }}"/;}' pyproject.toml
      - name: Build a binary wheel
        run: uv run python -m build
      # Test the locally built wheel
      - name: Create test environment
        run: uv venv test_before_testpypi
      - name: Test package installation and functionality
        run: |
          source test_before_testpypi/bin/activate
          # Install the locally built wheel and testing dependencies
          WHEEL_FILE=$(ls dist/*.whl | head -1)
          uv pip install "$WHEEL_FILE[dev]" pytest
          pytest tests/
          deactivate
      # Publish to test-PyPI
      - name: Publish distribution 📦 to test-PyPI
        uses: pypa/gh-action-pypi-publish@release/v1 # This requires a trusted publisher to be setup in pypi/testpypi
        with:
          repository-url: https://test.pypi.org/legacy/

  # TODO: Add tests using gepa

  build-and-publish-pypi:
    needs: [check-status, extract-tag, build-and-publish-test-pypi]
    # Only publish to PyPI if the repository owner is gepa-ai and status checks pass
    if: github.repository_owner == 'gepa-ai' && needs.check-status.outputs.status_checks_passed == 'true'
    runs-on: ubuntu-latest
    environment:
      name: pypi
    permissions:
      id-token: write # IMPORTANT: mandatory for trusted publishing
      contents: write
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Set up latest uv
        uses: astral-sh/setup-uv@v6
        with:
          version: latest
      - name: Install build dependencies
        run: uv pip install ".[build]"
      - name: Get correct version for PyPI release
        id: check_version
        run: |
          VERSION=${{ needs.extract-tag.outputs.version }}  
          PACKAGE_NAME="gepa"
          echo "Checking if $VERSION for $PACKAGE_NAME exists on PyPI"  
          NEW_VERSION=$(python3 .github/workflows/build_utils/test_version.py $PACKAGE_NAME $VERSION)  
          echo "Version to be used for PyPI release: $NEW_VERSION"  
          echo "version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
      - name: Update version in pyproject.toml
        run: sed -i '/#replace_package_version_marker/{n;s/version="[^"]*"/version="${{ steps.check_version.outputs.version }}"/;}' pyproject.toml
      - name: Build a binary wheel
        run: uv run python -m build
      # Test the locally built wheel before publishing to pypi
      - name: Create test environment
        run: uv venv test_before_pypi
      - name: Test package installation and functionality
        run: |
          source test_before_pypi/bin/activate
          # Install the locally built wheel and testing dependencies
          WHEEL_FILE=$(ls dist/*.whl | head -1)
          uv pip install "$WHEEL_FILE[dev]" pytest
          pytest tests/
          deactivate
          rm -r test_before_pypi
      - name: Publish distribution 📦 to PyPI (gepa)
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          attestations: false
      - uses: stefanzweifel/git-auto-commit-action@v5 # auto commit changes to main
        with:
          commit_message: Update versions
          create_branch: true
          branch: release-${{ needs.extract-tag.outputs.version }}
      - name: Checkout main branch
        run: |
          git fetch origin
          git checkout main
      - name: Configure git user
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "Github Actions"
      - name: Merge release branch into main
        run: |
          git merge --no-ff release-${{ needs.extract-tag.outputs.version }}
      - name: Push changes to main
        run: |
          git push origin main